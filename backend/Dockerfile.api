# # --- Stage 1: The "Build" Environment ---
# FROM golang:1.24-alpine AS builder

# WORKDIR /app

# # --- OPTIMIZATION 1: Leverage Docker Cache ---
# # Copy only the Go module files first. This layer is only rebuilt
# # if go.mod or go.sum change, not when your source code changes.
# COPY backend/go.mod backend/go.sum ./
# RUN go mod download

# # --- OPTIMIZATION 2: Copy Only What's Needed ---
# # Copy only the backend source code, not the whole 6.5GB project.
# COPY backend/ ./

# # --- THE FIX ---
# # The working directory is now /app, which contains go.mod.
# # The build command will work correctly from here.
# RUN CGO_ENABLED=0 GOOS=linux go build -o /app/server ./cmd/api


# # --- Stage 2: The "Production" Environment ---
# FROM alpine:latest

# # Install curl for the healthcheck
# RUN apk --no-cache add ca-certificates curl

# WORKDIR /app

# # Copy the compiled binary from the builder stage.
# COPY --from=builder /app/server .

# # Copy the ONNX model to the absolute path expected by the application.
# # This comes from the build context (the project root).
# COPY models/saved_models/champion_model.onnx /models/saved_models/champion_model.onnx

# EXPOSE 8080

# CMD ["/app/server"]

# --- Stage 1: The "Build" Environment ---
FROM golang:1.24-alpine AS builder
WORKDIR /app

# --- OPTIMIZATION 1: Leverage Docker Cache ---
# Since the context is already ./backend, just copy from the current directory
COPY go.mod go.sum ./
RUN go mod download

# --- OPTIMIZATION 2: Copy Only What's Needed ---
COPY . ./

# --- THE FIX ---
RUN CGO_ENABLED=0 GOOS=linux go build -o /app/server ./cmd/api

# --- Stage 2: The "Production" Environment ---
FROM alpine:latest
RUN apk --no-cache add ca-certificates curl
WORKDIR /app

# Copy the compiled binary from the builder stage
COPY --from=builder /app/server .

# Copy the ONNX model - this won't work with current context
# We'll need to handle this differently
EXPOSE 8080
CMD ["/app/server"]